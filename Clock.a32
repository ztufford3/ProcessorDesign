; Addresses for I/O
.NAME	HEX= 0xFFFFF000
.NAME	LEDR=0xFFFFF020
.NAME	KDATA= 0xFFFFF080
.NAME	KCTL= 0xFFFFF084
.NAME	SW=  0xFFFFF090
.NAME	SWCTl= 0xFFFFF094
.NAME TCNT=0xFFFFF100
.NAME TLIM=0xFFFFF104
.NAME TCTL=0xFFFFF108
.NAME SECLO=0xF
.NAME SECHI=0xF0
.NAME SECS=0xFF
.NAME SECLOMAX=0x9
.NAME SECHIMAX=0x50
.NAME MINLO=0xF00
.NAME MINLOMAX=0x900
.NAME MINHI=0xF000
.NAME MINHIMAX=0x5000
.NAME HRLO=0xF0000
.NAME HRHI=0xF00000
.NAME HRLOMAX=0x90000

.NAME INCSECLOW=0x1
.NAME INCSECHIGH=0x10
.NAME INCMINLOW=0x100
.NAME INCMINHIGH=0x1000
.NAME INCHRLOW=0x10000
.NAME INCHRHIGH=0x100000

.NAME HRMAX=0x230000
.NAME MINSMAX=0x5900
.NAME SECSMAX=0x59



	.ORIG 0x100
	ADDI a0,Zero,10
	ADDI s0,Zero,0; ONE DENOTES CLOCK SET, ZERO DENOTES CLOCK DISP
	SW a0,TLIM(Zero)
	LW t1,HrMaxVal(Zero)
	ADD t0,Zero,t1; t0=23 hrs
	LW t1,MinsMaxVal(Zero)
	ADD t0,t0,t1; t0=23 hrs 59 mins
	LW t1,SecHiMaxVal(Zero)
	SUBI t1,t1,11
	ADD t0,t0,t1; t0=23 hrs 59 mins 45 secs
	SW Zero,TCTL(Zero)
	SW t0,HEX(Zero)
Disp:
	ADDI a1,Zero,1
	ADDI a2,Zero,100
	ADDI a5,Zero,0
	ADDI s5,Zero,200
	ADDI a10,Zero,500
ClockLoop:
	ANDI s0,Zero,0; set mode to display
	LW a3,KDATA(Zero)
	ANDI a3,a3,1; is 1 if key0 is being pressed
	GT t8,a5,Zero
	SW t8,LEDR(Zero); turn on LEDR0 if the key timer goes beyond 0 secs
	BEQ a3,a1,UpdKeyTimer ; branch if key0press==1
	AND a5,a5,Zero; zero out key timer if key0 isn't being pressed
UpdKeyTimer:
	EQ a4,a3,a1
	LW s1,TCTL(Zero)
	NOT t0,s1
	SW t0,TCTL(Zero); 
	ADD a0,a0,s1; will increment if ready bit is set
	AND a4,a4,s1; a4=1 if key0 is being pressed and if the timer has the ready bit set
	ADD a5,a5,a4; increment key timer by 1 if key0 is being pressed and the timer's ready bit is set
	BEQ a5,s5,ClockSet
	BEQ a0,a2,IncSecLo; branch if we've counted 100 hundreths of a second
	BNE s0,Zero,ClockSetLoop
	BR  ClockLoop
IncSecLo:
	LW s2,HEX(Zero)
	LW t0,SecLoVal(Zero)
	AND s3,s2,t0; grab the low sec digit
	LW t0,SecLoMaxVal(Zero)
	BEQ s3,t0,IncSecHi; if it's 9, jump, otherwise, add a sec and update
	LW t1,SecLoIncVal(Zero)
	ADD s2,s2,t1; secs +1
	SW s2,HEX(Zero)
	AND a0,a0,Zero
	BNE s0,Zero,ClockSetLoop
	BR ClockLoop
IncSecHi:
	LW t0,SecHiVal(Zero)
	AND s3,s2,t0; grab the higher sec digit
	LW t0,SecHiMaxVal(Zero); check if sec hi is 5
	BEQ s3,t0,IncMinLo; increment the minute if secs==59, otherwise add increment sec hi, zero sec lo, and update
	LW t0,SecHiIncVal(Zero)
	ADD s2,s2,t0; +10 secs
	LW t0,SecLoMaxVal(Zero)
	SUB s2,s2,t0; secs has to be 9 here, so sub 9 to make it 0
	SW s2,HEX(Zero)
	AND a0,a0,Zero
	BNE s0,Zero,ClockSetLoop
	BR ClockLoop
IncMinLo:
	BEQ s0,Zero,Skip
	LW t0,SecsMaxVal(Zero); have secs wrap when in clock set mode
	SUB s2,s2,t0
	SW s2,HEX(Zero)
	BR ClockSetLoop
Skip:
	LW t0,MinLoVal(Zero)
	AND s3,s2,t0; grab the lower min digit
	LW t0,MinLoMaxVal(Zero); check if min lo is 9
	BEQ s3,t0,IncMinHi; if min lo is 9, need to inc min hi, else inc min lo and reset secs
	LW t0,MinLoIncVal(Zero)
	ADD s2,s2,t0; +1 min
	LW t0,SecsMaxVal(Zero)
	SUB s2,s2,t0; -59 secs
	SW s2,HEX(Zero)
	AND a0,a0,Zero
	BR ClockLoop
IncMinHi:
	LW t0,MinHiVal(Zero)
	AND s3,s2,t0; grab higher min digit
	LW t0,MinHiMaxVal(Zero); check if min hi is 5 
	BEQ s3,t0,IncHourLo; if mins==59, inc hour, otherwise do +10mins and reset min lo and secs
	LW t0,MinHiIncVal(Zero)
	ADD s2,s2,t0; +10 mins
	LW t0,MinLoMaxVal(Zero)
	LW t1,SecsMaxVal(Zero)
	ADD t0,t0,t1; t0=9 mins 59 secs
	SUB s2,s2,t0; -9 mins and 59 secs
	SW s2,HEX(Zero)
	AND a0,a0,Zero
	BR ClockLoop
IncHourLo:
	LW t1,HrLoVal(Zero)
	LW t2,HrHiVal(Zero)
	ADD t1,t1,t2; t1=hrs lo + hrs hi
	AND s3,s2,t1
	LW t0,HrMaxVal(Zero); check if hrs==23
	BEQ s3,t0,SetZero; set clock display to 00:00:00 if 23:59:59, else, check if hr lo is 9
	LW t0,HrLoMaxVal(Zero); hrlo==9
	BEQ s3,t0,IncHrHi; increment the hi hour digit if lo is 9, otherwise add an hour and reset mins and secs
	LW t0,HrLoIncVal(Zero)
	ADD s2,s2,t0; +1hr lo
	LW t0,MinsMaxVal(Zero); t0=59 mins
	LW t1,SecsMaxVal(Zero); t1=59 secs
	ADD t0,t0,t1; t0=59 mins 59 secs
	SUB s2,s2,t0; -59 mins 59 secs
	SW s2,HEX(Zero)
	AND a0,a0,Zero
	BR ClockLoop
IncHourHi:
	LW t0,HrHiVal(Zero)
	AND s3,s2,t0; grab higher hr digit
	LW t0,HrHiIncVal(Zero)
	ADD s2,s2,t0; +10 hrs
	LW t0,HrLoMaxVal(Zero)
	LW t1,MinsMaxVal(Zero)
	ADD t0,t0,t1; t0=9 hrs 59 mins
	LW t1,SecsMaxVal(Zero)
	ADD t0,t0,t1; t0=9 hrs 59 mins 59 secs
	SUB s2,s2,t0; -9 hrs 59 mins 59 secs
	SW s2,HEX(Zero)
	AND a0,a0,Zero
	BR ClockLoop
SetZero:
	SW Zero,HEX(Zero)
	AND a0,a0,Zero
	BR ClockLoop



ClockSet:
	ANDI a5,Zero,0; set key timer counter back to 0
	ADDI s0,Zero,1; set mode to cock set
	ANDI t4,Zero,0
	ANDI t6,Zero,0
	ANDI t6,Zero,0
	ANDI t7,Zero,0
	ANDI s4,Zero,0
	ANDI s5,Zero,0
	ANDI s6,Zero,0
	ANDI s7,Zero,0
	ADDI t13,Zero,15
ClockSetLoop:
	NOT t12,Zero
	SW t12,LEDR(Zero)
	ADD s4,Zero,t4; store last cycle's key vals
	ADD s5,Zero,t5
	ADD s6,Zero,t6
	ADD s7,Zero,t7
	LW a3,KDATA(Zero)
	ADDI t4,Zero,14; only key0 being pressed
	NEQ s8,t4,a3
	ADDI t5,Zero,13; only key1 being pressed
	NEQ s9,t5,a3
	ADDI t6,Zero,11; only key2 being pressed
	NEQ s10,t6,a3
	ADDI t7,Zero,7; only key3 being pressed
	NEQ s11,t7,a3

	AND s4,s4,s8; key0 was pressed but now isn't
	AND s5,s5,s9; key1 was pressed but now isn't
	AND s6,s6,s10; key2 was pressed but now isn't
	AND s7,s7,s11; key3 was pressed but now isn't

	BEQ s4,a1,SetDecMinLo
	BEQ s5,a1,SetIncMinLo
	BEQ s6,a1,SetDecHrLo
	BEQ s7,a1,SetIncHrLo

	BNE a3,t13,UpdKeyTimerSet ; branch if any key pressed
	AND a5,a5,Zero; zero out key timer if any key is pressed
UpdKeyTimerSet:
	LW s1,TCTL(Zero)
	NOT t0,s1
	SW t0,TCTL(Zero); 
	ADD a0,a0,s1; will increment if ready bit is set
	EQ a4,a13,a3; a4=1 if no key is being pressed
	AND a4,a4,s1; a4=1 if no key is being pressed and if the timer has the ready bit set
	ADD a5,a5,a4; increment key timer by 1 if key0 is being pressed and the timer's ready bit is set
	BEQ a5,a10,Disp; go back to display mode if 5 seconds have passed without a keypress
	BEQ a0,a2,IncSecLo; branch if we've counted 100 hundreths of a second
	BR  ClockSetLoop

SetDecMinLo:
	LW s2,HEX(Zero)
	LW t0,MinLoVal(Zero)
	AND s3,s2,t0; grab the lower min digit
	BEQ s3,Zero,SetDecMinHi; if min lo is 0, decrement min hi
	LW t0,MinLoIncVal(Zero)
	SUB s2,s2,t0; -1 min
	LW t0,SecsVal(Zero)
	AND t0,s2,t0; grab seconds
	SUB s2,s2,t0; -set secs to 0
	SW s2,HEX(Zero)
	BR UpdKeyTimerSet; let secs increment per normal

SetDecMinHi:
BR UpdKeyTimerSet;

SecsVal:
	.WORD SECS
SecLoVal:
	.WORD SECLO
SecLoMaxVal:
	.WORD SECLOMAX
SecHiVal:
	.WORD SECHI
SecHiMaxVal:
	.WORD SECHIMAX
MinLoVal:
	.WORD MINLO
MinLoMaxVal:
	.WORD MINLOMAX
MinHiVal:
	.WORD MINHI
MinHiMaxVal:
	.WORD MINHIMAX
HrLoVal:
	.WORD HRLO
HrLoMaxVal:
	.WORD HRLOMAX
HrHiVal:
	.WORD HRHI

SecLoIncVal:
	.WORD INCSECLOW
SecHiIncVal:
	.WORD INCSECHIGH
MinLoIncVal:
	.WORD INCMINLOW
MinHiIncVal:
	.WORD INCMINHIGH
HrLoIncVal:
	.WORD INCHRLOW
HrHiIncVal:
	.WORD INCHRHIGH

HrMaxVal:
	.WORD HRMAX
MinsMaxVal:
	.WORD MINSMAX
SecsMaxVal:
	.WORD SECSMAX